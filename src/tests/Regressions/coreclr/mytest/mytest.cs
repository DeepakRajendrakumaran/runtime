// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

// Adapted from:
// Generated by Fuzzlyn v1.5 on 2022-11-14 02:52:08
// Run on Arm64 Windows
// Seed: 11038715273855459808
// Reduced from 96.6 KiB to 0.9 KiB in 00:08:38
// Debug: Outputs 0
// Release: Outputs 1
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Numerics;
using System.Runtime.Intrinsics.X86;
//using System.Runtime.Intrinsics.x86;


public class mytest
{

    private static readonly int ElementCount512 = Unsafe.SizeOf<Vector512<Int32>>() / sizeof(Int32);
    private static readonly int ElementCount256 = Unsafe.SizeOf<Vector256<Int32>>() / sizeof(Int32);
    public static unsafe int Main()
    {
        Vector512<byte> v512_1 = Vector512.Create(2).AsByte();
        Vector512<byte> v512_2 = Vector512.Create(3).AsByte();
        Vector512<byte> v512_3 = Vector512.Create(2).AsByte();
        //Vector512<byte> v512_4 = Vector512.Create(3);
        Vector512<byte> v512_res = Vector512Expt(v512_1, v512_2, v512_3);

        Console.Write("\n Vector512Expt: ");
        for (int index = 0; index < Vector512<byte>.Count; index++)
        {
            Console.Write(" " + v512_res[index]);
        }

        /*Console.WriteLine("\n Vector128Dot Begin \n");
        Vector128<int> v128_1 = Vector128.Create(
                       (int)1, 2, 3, 4); // 30
        int v128Dot = Vector128Dot(v128_1, v128_1);
        Console.WriteLine("\n Vector128Dot: " + v128Dot);


        Console.WriteLine("\n Vector256Dot Begin \n");
        Vector256<int> v256_1 = Vector256.Create(
                       (int)1, 2, 3, 4, 5, 6, 7, 8); // 204
        int v256Dot = Vector256Dot(v256_1, v256_1);
        Console.WriteLine("\n Vector256Dot: " + v256Dot);


        Console.WriteLine("\n Vector512Dot Begin \n");
        Vector512<int> v512_1 = Vector512.Create(
                       (int)1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16); // 1496
        int v512Dot = Vector512Dot(v512_1, v512_1);
        Console.WriteLine("\n Vector512Dot: " + v512Dot);


        Console.WriteLine("\n Vector512Multiply Begin \n");
        Vector512<short> v512Mul = Vector512Multiply(v512_1.AsInt16(), v512_1.AsInt16());
        Console.Write("\n Vector512Multiply: ");
        for (int index = 0; index < Vector512<short>.Count; index++)
        {
            Console.Write(" " + v512Mul[index]);
        }
        Console.Write("\n Vector512Multiply DONE ");*/

        //Console.WriteLine("\n Vector128Sum Begin \n");
        /*Vector128<byte> v128_1 = Vector128.Create(
                       (byte)1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);
        byte v128Sum = Vector128Sum(v128_1);*/

        /*Vector128<short> v128_1 = Vector128.Create(
                       (short)0, 0, 0, 0, 3, 0, 0, 0);
        short v128Sum = Vector128Sum(v128_1);*/

        /*Vector128<float> v128_1 = Vector128.Create(
                       (float)4, 7, 9, 5); 
        float v128Sum = Vector128Sum(v128_1);*/

        //Vector128<int> v128_1 = Vector128.Create(
        //(int)6, 4, 7, 15);
        //int v128Sum = Vector128Sum(v128_1);

        /*Vector128<double> v128_1 = Vector128.Create(
                       (double)4, 7); 
        double v128Sum = Vector128Sum(v128_1);*/

        /*Vector128<long> v128_1 = Vector128.Create(
                       (long)6, 4);
        long v128Sum = Vector128Sum(v128_1);*/

        //Console.WriteLine("\n Vector128Sum: " + v128Sum);

        /*Console.WriteLine("\n Vector256Sum Begin \n");
        Vector256<int> v256_1 = Vector256.Create(
                       (int)1, 2, 3, 4, 5, 6, 7, 8); //36
        int v256Sum = Vector256Sum(v256_1);
        Console.WriteLine("\n Vector256Sum: " + v256Sum);


        Console.WriteLine("\n Vector512Sum Begin \n");
        Vector512<int> v512_1Sum = Vector512.Create(
                       (int)1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16); //136
        int v512Sum = Vector512Sum(v512_1Sum);
        Console.WriteLine("\n Vector512Sum: " + v512Sum);*/


        /*if (Avx512BW.IsSupported)
        {
            Console.WriteLine("\n vec512Shuffle Begin \n");
            Vector512<short> v512_1 = Vector512.Create(
                           (short)63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48,
                           47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32);
            Vector512<short> v512_2 = Vector512.Create(
                            (short)31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,
                            15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0);

            Vector512<sbyte> v512_narrow = Vector512.Narrow(v512_1, v512_2);
            Console.WriteLine("\n Narrow Vals: ");
            for (int index = 0; index < Vector512<sbyte>.Count; index++)
            {
                Console.Write(" " + v512_narrow[index]);
            }
            Vector512<byte> v512_packed = PackSources(v512_1, v512_2);
            Console.WriteLine("\n PackSources Vals: ");
            for (int index = 0; index < Vector512<byte>.Count; index++)
            {
                Console.Write(" " + v512_packed[index]);
            }
            Console.WriteLine("\n PackSources Done \n");

            Vector512<byte> v512_permute = FixUpPackedVector512Result(v512_packed);
            Console.WriteLine("\n FixUpPackedVector512Result Vals: ");
            for (int index = 0; index < Vector512<byte>.Count; index++)
            {
                Console.Write(" " + v512_permute[index]);
            }
            Console.WriteLine("\n FixUpPackedVector512Result Done \n");

        }*/

        /*Console.WriteLine("\n vec512Shuffle Begin \n");
        Vector512<byte> v512Shuffle = Vector512.Create(
                        (byte)63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48,
                        47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32,
                        31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,
                        15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0);
        Vector512<byte> resultElements512Shuffle = vec512Shuffle(v512Shuffle);
        Console.WriteLine("\n vec512Shuffle Vals: ");
        for (int index = 0; index < Vector512<byte>.Count; index++)
        {
            Console.WriteLine(" " + resultElements512Shuffle[index]);
        }
        Console.WriteLine("\n vec512Shuffle Done \n");

        Console.WriteLine("\n vec256ShuffleByte Begin \n");
        Vector256<byte> v256ShuffleByte = Vector256.Create(
                        (byte)31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,
                        15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0);
        Vector256<byte> resultElements256ShuffleByte = vec256ShuffleByte(v256ShuffleByte);
        Console.WriteLine("\n vec256ShuffleByte Vals: ");
        for (int index = 0; index < Vector256<byte>.Count; index++)
        {
            Console.WriteLine(" " + resultElements256ShuffleByte[index]);
        }
        Console.WriteLine("\n vec256ShuffleByte Ends\n");

        Console.WriteLine("\n vec256ShuffleInt Begin \n");
        Vector256<long> v256ShuffleInt = Vector256.Create(
                        (long)3, 2, 1, 0);
        Vector256<long> resultElements256ShuffleInt = vec256ShuffleInt(v256ShuffleInt);
        Console.WriteLine("\n vec256ShuffleInt Vals: ");
        for (int index = 0; index < Vector256<long>.Count; index++)
        {
            Console.WriteLine(" " + resultElements256ShuffleInt[index]);
        }
        Console.WriteLine("\n vec256ShuffleInt Ends\n");*/


        return -1;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Vector512<byte> Vector512Expt(Vector512<byte> v512_1, Vector512<byte> v512_2, Vector512<byte> v512_3)
    {
        return Vector512.Equals(v512_1^ v512_2, Vector512<byte>.Zero) | Vector512.Equals(v512_1 ^ v512_3, Vector512<byte>.Zero);
        //return Vector512.Equals(v512_1, v512_2) | Vector512.Equals(v512_1, v512_3);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static byte Vector128Sum(Vector128<byte> input)
    {
        return Vector128.Sum(input);
    }


    [MethodImpl(MethodImplOptions.NoInlining)]
    private static short Vector128Sum(Vector128<short> input)
    {
        return Vector128.Sum(input);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static float Vector128Sum(Vector128<float> input)
    {
        return Vector128.Sum(input);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static int Vector128Sum(Vector128<int> input)
    {
        return Vector128.Sum(input);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static double Vector128Sum(Vector128<double> input)
    {
        return Vector128.Sum(input);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static long Vector128Sum(Vector128<long> input)
    {
        return Vector128.Sum(input);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static int Vector512Sum(Vector512<int> input)
    {
        return Vector512.Sum(input);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static int Vector128Dot(Vector128<int> input1, Vector128<int> input2)
    {
        return Vector128.Dot(input1, input2);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static int Vector256Dot(Vector256<int> input1, Vector256<int> input2)
    {
        return Vector256.Dot(input1, input2);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static int Vector512Dot(Vector512<int> input1, Vector512<int> input2)
    {
        return Vector512.Dot(input1, input2);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Vector512<int> Vector512Multiply(Vector512<int> input1, Vector512<int> input2)
    {
        return Vector512.Multiply(input1, input2);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Vector512<byte> Vector512Multiply(Vector512<byte> input1, Vector512<byte> input2)
    {
        return Vector512.Multiply(input1, input2);
    }
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Vector512<short> Vector512Multiply(Vector512<short> input1, Vector512<short> input2)
    {
        return Vector512.Multiply(input1, input2);
    }
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Vector512<long> Vector512Multiply(Vector512<long> input1, Vector512<long> input2)
    {
        return Vector512.Multiply(input1, input2);
    }
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Vector512<float> Vector512Multiply(Vector512<float> input1, Vector512<float> input2)
    {
        return Vector512.Multiply(input1, input2);
    }
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Vector512<double> Vector512Multiply(Vector512<double> input1, Vector512<double> input2)
    {
        return Vector512.Multiply(input1, input2);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
   // [CompExactlyDependsOn(typeof(Avx512BW))]
    private static Vector512<byte> PackSources(Vector512<short> source0, Vector512<short> source1)
    {
        //Debug.Assert(Avx512BW.IsSupported);
        // Pack two vectors of characters into bytes. While the type is Vector256<short>, these are really UInt16 characters.
        // X86: Downcast every character using saturation.
        // - Values <= 32767 result in min(value, 255).
        // - Values  > 32767 result in 0. Because of this we can't accept needles that contain 0.
        return Avx512BW.PackUnsignedSaturate(source0, source1).AsByte();
        //return Avx512BW.PackUnsignedSaturate(source0, source1).AsByte();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
  //  [CompExactlyDependsOn(typeof(Avx512F))]
    private static Vector512<byte> FixUpPackedVector512Result(Vector512<byte> result)
    {
        //Debug.Assert(Avx512F.IsSupported);
        // Avx512BW.PackUnsignedSaturate(Vector512.Create((short)1), Vector512.Create((short)2)) will result in
        // 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2
        // We want to swap the X and Y bits
        // 1, 1, 1, 1, 1, 1, 1, 1, X, X, X, X, X, X, X, X, Y, Y, Y, Y, Y, Y, Y, Y, 2, 2, 2, 2, 2, 2, 2, 2
        return Avx512F.PermuteVar8x64(result.AsInt64(), Vector512.Create((long)0, 2, 4, 6, 1, 3, 5, 7)).AsByte();
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static Vector256<byte> vec256ShuffleByte(Vector256<byte> input)
    {
        return Vector256.Shuffle(input, Vector256.Create(
                        (byte)31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,
                        15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0));
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static Vector256<long> vec256ShuffleInt(Vector256<long> input)
    {
        return Vector256.Shuffle(input, Vector256.Create(
                        (long)3, 2, 1, 0));
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static Vector512<byte> vec512Shuffle(Vector512<byte> input)
    {
        return Vector512.Shuffle(input, Vector512.Create(
                        (byte)63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48,
                        47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32,
                        31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,
                        15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0));
    }

    

}
